<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>百度直连(免流)</title>
      <link href="/486381511/2022/05/15/bai-du-zhi-lian-mian-liu/"/>
      <url>/486381511/2022/05/15/bai-du-zhi-lian-mian-liu/</url>
      
        <content type="html"><![CDATA[<h2 id="ml（定向转通用，自由奔放）"><a href="#ml（定向转通用，自由奔放）" class="headerlink" title="ml（定向转通用，自由奔放）"></a>ml（定向转通用，自由奔放）</h2><h3 id="首先你需要的条件："><a href="#首先你需要的条件：" class="headerlink" title="首先你需要的条件："></a>首先你需要的条件：</h3><h3 id="1-已root的安卓手机一台"><a href="#1-已root的安卓手机一台" class="headerlink" title="1.已root的安卓手机一台"></a>1.已root的安卓手机一台</h3><h3 id="2-刷入Magisk"><a href="#2-刷入Magisk" class="headerlink" title="2.刷入Magisk"></a>2.刷入Magisk</h3><h3 id="3-定向流量多的一张卡，最好百度定向"><a href="#3-定向流量多的一张卡，最好百度定向" class="headerlink" title="3.定向流量多的一张卡，最好百度定向"></a>3.定向流量多的一张卡，最好百度定向</h3><p><strong>magisk刷入百度直连</strong><br><img src="/486381511/medias/bdzl/0.jpg"><br><img src="/486381511/medias/bdzl/1.jpg"><br><img src="/486381511/medias/bdzl/2.jpg"></p><p><strong>mt管理器里面设置好配置</strong><br><strong>路径是根目录下data/百度直连/</strong><br><img src="/486381511/medias/bdzl/3.jpg"><br><strong>设置UA伪装，就这两个位置</strong><br><img src="/486381511/medias/bdzl/4.jpg"><br><strong>保存，运行</strong><br><img src="/486381511/medias/bdzl/5.jpg"><br><strong>效果</strong><br><img src="/486381511/medias/bdzl/6.jpg"><br><img src="/486381511/medias/bdzl/7.png"><br><strong>可以自由奔放了，唯一缺点就是不能再开别的代理，手机无法出国，打游戏就去配置里面放行该游戏就行了</strong></p>]]></content>
      
      
      <categories>
          
          <category> ml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yolo简单使用</title>
      <link href="/486381511/2022/05/15/yolo-jian-dan-shi-yong/"/>
      <url>/486381511/2022/05/15/yolo-jian-dan-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="yolo简单使用（调参侠）"><a href="#yolo简单使用（调参侠）" class="headerlink" title="yolo简单使用（调参侠）"></a>yolo简单使用（调参侠）</h1><h2 id="首先下载好yolo项目文件，安装好各种支持yolo运行的第三方库"><a href="#首先下载好yolo项目文件，安装好各种支持yolo运行的第三方库" class="headerlink" title="首先下载好yolo项目文件，安装好各种支持yolo运行的第三方库"></a>首先下载好yolo项目文件，安装好各种支持yolo运行的第三方库</h2><h1 id="1-调用yolo官方自带已经训练好的模型进行物体检测"><a href="#1-调用yolo官方自带已经训练好的模型进行物体检测" class="headerlink" title="1.调用yolo官方自带已经训练好的模型进行物体检测"></a>1.调用yolo官方自带已经训练好的模型进行物体检测</h1><p><strong>其他先不要动，找到项目中detect.py文件，里面是yolo跑模型的代码，找到方法parse_opt()，这里就是我们要修改的地方，我们要做的只是调参（小白）</strong></p><p><img src="/486381511/medias/yolo/0.png"></p><p><strong>weights是训练好的权重，这里我们要修改的是ROOT /后面引号里的内容，我们可以把训练好的模型放在项目根目录，这里写上训练好的权重文件的文件名就可以了，可以去官方下载官方提供的，这里我使用了我自己训练好名为fish.pt的权重文件</strong></p><p><img src="/486381511/medias/yolo/1.png"></p><p><strong>source是用于检测目标的文件，文件夹里面可以放照片，视频……  例如我的图片就存在’mydata/images/test’里面</strong><br><img src="/486381511/medias/yolo/2.png"></p><p><strong>imgsz不管</strong><br><strong>conf-thres是置信度，一定阈值才在图片上标记，例如这里，当yolo有20%的概率认为这个物体是鱼时，yolo就会标记</strong><br><img src="/486381511/medias/yolo/3.png"></p><p>其他的都是不大影响我们正常输出的，具体可以看yolo官方文档</p><p>完成到这里我们就可以进行目标检测了<br>结果保存在run文件目录下<br><img src="/486381511/medias/yolo/4.png"></p><h1 id="2-训练模型"><a href="#2-训练模型" class="headerlink" title="2.训练模型"></a>2.训练模型</h1><h2 id="首先找到根目录下的train-py文件"><a href="#首先找到根目录下的train-py文件" class="headerlink" title="首先找到根目录下的train.py文件"></a>首先找到根目录下的train.py文件</h2><p><img src="/486381511/medias/yolo/5.png"><br><strong>weights是我们要继承的权重，建议继承官方的，我写过不继承的，一直报错</strong><br><img src="/486381511/medias/yolo/6.png"><br><strong>cfg是模型的结构，其路径在models文件夹下，选择我们需要的模型就行了，模型越复杂需要时间越长</strong><br><img src="/486381511/medias/yolo/7.png"><br><img src="/486381511/medias/yolo/8.png"><br><strong>data是指定配置数据集的文件，我在data文件下魔改了coco数据集的配置文件，生成了mydata配置文件</strong><br><img src="/486381511/medias/yolo/10.png"><br><img src="/486381511/medias/yolo/9.png"><br><strong>下面的参数简单介绍</strong><br><strong>epochs是训练的轮数，训练不一定是越多越好，有可能出现过拟合现象</strong><br><strong>batch-size是一次训练多少张照片</strong><br><strong>resume是断点重连</strong><br><img src="/486381511/medias/yolo/11.png"><br><strong>如果有gpu，device可以填0，没有就填cpu，这个要装GPU版本的pytorch，具体问度娘</strong></p><h1 id="制作数据集"><a href="#制作数据集" class="headerlink" title="制作数据集"></a>制作数据集</h1><h2 id="上面我们写数据集配置文件时，那个路径是我们自己构建的，首先在根目录下随便建立一个文件夹，我的是mydata"><a href="#上面我们写数据集配置文件时，那个路径是我们自己构建的，首先在根目录下随便建立一个文件夹，我的是mydata" class="headerlink" title="上面我们写数据集配置文件时，那个路径是我们自己构建的，首先在根目录下随便建立一个文件夹，我的是mydata"></a>上面我们写数据集配置文件时，那个路径是我们自己构建的，首先在根目录下随便建立一个文件夹，我的是mydata</h2><h2 id="然后在mydata文件夹中，就要建立两个yolo规定的文件夹了，一个是images，一个是labels"><a href="#然后在mydata文件夹中，就要建立两个yolo规定的文件夹了，一个是images，一个是labels" class="headerlink" title="然后在mydata文件夹中，就要建立两个yolo规定的文件夹了，一个是images，一个是labels"></a>然后在mydata文件夹中，就要建立两个yolo规定的文件夹了，一个是images，一个是labels</h2><p><img src="/486381511/medias/yolo/12.png"></p><h2 id="images里面存放你的数据集，也就是图片"><a href="#images里面存放你的数据集，也就是图片" class="headerlink" title="images里面存放你的数据集，也就是图片"></a>images里面存放你的数据集，也就是图片</h2><h2 id="labels存放图片的标签，这里要展开说一下"><a href="#labels存放图片的标签，这里要展开说一下" class="headerlink" title="labels存放图片的标签，这里要展开说一下"></a>labels存放图片的标签，这里要展开说一下</h2><h1 id="如何制作标签"><a href="#如何制作标签" class="headerlink" title="如何制作标签"></a>如何制作标签</h1><h2 id="建议使用https-www-makesense-ai-网站（过墙），在线打标，免费的"><a href="#建议使用https-www-makesense-ai-网站（过墙），在线打标，免费的" class="headerlink" title="建议使用https://www.makesense.ai/网站（过墙），在线打标，免费的"></a>建议使用<a href="https://www.makesense.ai/%E7%BD%91%E7%AB%99%EF%BC%88%E8%BF%87%E5%A2%99%EF%BC%89%EF%BC%8C%E5%9C%A8%E7%BA%BF%E6%89%93%E6%A0%87%EF%BC%8C%E5%85%8D%E8%B4%B9%E7%9A%84">https://www.makesense.ai/网站（过墙），在线打标，免费的</a></h2><p>网站首页右下角<br><img src="/486381511/medias/yolo/13.png"><br><img src="/486381511/medias/yolo/14.png"><br><img src="/486381511/medias/yolo/15.png"><br><img src="/486381511/medias/yolo/16.png"><br>标记完，就导出<br><img src="/486381511/medias/yolo/17.png"><br><img src="/486381511/medias/yolo/18.png"></p><h2 id="把标签全部移动到mydata下的labels文件夹下"><a href="#把标签全部移动到mydata下的labels文件夹下" class="headerlink" title="把标签全部移动到mydata下的labels文件夹下"></a>把标签全部移动到mydata下的labels文件夹下</h2><h2 id="上面填数据集配置内容时，我们不需要写labels路径的，yolo会检索images文件，然后在同级目录在自动检索labels文件夹的"><a href="#上面填数据集配置内容时，我们不需要写labels路径的，yolo会检索images文件，然后在同级目录在自动检索labels文件夹的" class="headerlink" title="上面填数据集配置内容时，我们不需要写labels路径的，yolo会检索images文件，然后在同级目录在自动检索labels文件夹的"></a>上面填数据集配置内容时，我们不需要写labels路径的，yolo会检索images文件，然后在同级目录在自动检索labels文件夹的</h2><h1 id="完成我们就可以运行train-py文件了，它的结果会生成在runs-x2F-train下面的，我们对应找到best-pt-这个就是最好的权重，然后我们回到上面，在detect-py中换成我们自己训练的权重，然后操作不变，就可以用于检测我们需要的目标"><a href="#完成我们就可以运行train-py文件了，它的结果会生成在runs-x2F-train下面的，我们对应找到best-pt-这个就是最好的权重，然后我们回到上面，在detect-py中换成我们自己训练的权重，然后操作不变，就可以用于检测我们需要的目标" class="headerlink" title="完成我们就可以运行train.py文件了，它的结果会生成在runs/train下面的，我们对应找到best.pt,这个就是最好的权重，然后我们回到上面，在detect.py中换成我们自己训练的权重，然后操作不变，就可以用于检测我们需要的目标"></a>完成我们就可以运行train.py文件了，它的结果会生成在runs/train下面的，我们对应找到best.pt,这个就是最好的权重，然后我们回到上面，在detect.py中换成我们自己训练的权重，然后操作不变，就可以用于检测我们需要的目标</h1><p><strong>更多进阶要学深度学习，自己改接口，用于自己项目</strong></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> yolo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建简单网络</title>
      <link href="/486381511/2022/05/15/gou-jian-jian-dan-wang-luo/"/>
      <url>/486381511/2022/05/15/gou-jian-jian-dan-wang-luo/</url>
      
        <content type="html"><![CDATA[<h1 id="深度学习————简单示例"><a href="#深度学习————简单示例" class="headerlink" title="深度学习————简单示例"></a>深度学习————简单示例</h1><h3 id="由数据和结果，推断中间过程，得到一个结果网络可以用于预测和识别物体"><a href="#由数据和结果，推断中间过程，得到一个结果网络可以用于预测和识别物体" class="headerlink" title="由数据和结果，推断中间过程，得到一个结果网络可以用于预测和识别物体"></a>由数据和结果，推断中间过程，得到一个结果网络可以用于预测和识别物体</h3><h3 id="任务：由数据-1-0-2-0-3-0"><a href="#任务：由数据-1-0-2-0-3-0" class="headerlink" title="任务：由数据 1.0 2.0 3.0"></a>任务：由数据 1.0 2.0 3.0</h3><h3 id="结果：4-0-8-0-12-0"><a href="#结果：4-0-8-0-12-0" class="headerlink" title="结果：4.0 8.0 12.0"></a>结果：4.0 8.0 12.0</h3><h3 id="推断中间过程（人眼很简单可以看出关系是乘上4得到结果）"><a href="#推断中间过程（人眼很简单可以看出关系是乘上4得到结果）" class="headerlink" title="推断中间过程（人眼很简单可以看出关系是乘上4得到结果）"></a>推断中间过程（人眼很简单可以看出关系是乘上4得到结果）</h3><h2 id="导入torch"><a href="#导入torch" class="headerlink" title="导入torch"></a>导入torch</h2><p><strong>pytorch是一个基本的深度学习框架，封装好了各种方法</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> torch</code></pre><h2 id="准备数据和结果"><a href="#准备数据和结果" class="headerlink" title="准备数据和结果"></a>准备数据和结果</h2><pre class=" language-python"><code class="language-python">x_data <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3.0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>y_data <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">4.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">8.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">12.0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h2 id="构建你的模型"><a href="#构建你的模型" class="headerlink" title="构建你的模型"></a>构建你的模型</h2><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 设计模型</span><span class="token keyword">class</span> <span class="token class-name">LinearModel</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 没有backward，torch.nn.Module 中会自动算来的</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 调用父类构造</span>        super<span class="token punctuation">(</span>LinearModel<span class="token punctuation">,</span>self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 实例化Linear对象，包含了权重w和偏置b，第一个1是输入维数，第二个1是输出维数</span>        self<span class="token punctuation">.</span>linear <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 向前传播</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 传入x，自动算 y = wx+b</span>        y_pred <span class="token operator">=</span> self<span class="token punctuation">.</span>linear<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">return</span> y_pred<span class="token comment" spellcheck="true"># 创建模型对象</span>module <span class="token operator">=</span> LinearModel<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="构建损失函数和优化器"><a href="#构建损失函数和优化器" class="headerlink" title="构建损失函数和优化器"></a>构建损失函数和优化器</h2><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 构造损失函数和优化器</span><span class="token comment" spellcheck="true"># 实例化，损失函数，将来给y'和y就可以算出loss，MSE平方损失函数</span>criterion <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>MSELoss<span class="token punctuation">(</span>size_average<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 不乘上1/N</span><span class="token comment" spellcheck="true"># 优化器，优化optim模块里面的一个SGD类，实例化，module.parameters()会检查所有成员，如果这个成员有相应的权重就把这些都加都训练集合上</span><span class="token comment" spellcheck="true"># lr：学习率</span>optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>module<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>lr<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># w=w-lr*(dloss/dw)</span></code></pre><h2 id="训练（向前传播、反向传播和更新权重偏置）"><a href="#训练（向前传播、反向传播和更新权重偏置）" class="headerlink" title="训练（向前传播、反向传播和更新权重偏置）"></a>训练（向前传播、反向传播和更新权重偏置）</h2><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 先训练一百次</span><span class="token keyword">for</span> epoch <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 送入x_data数据集，然后算 y'=wx+b</span>    y_pred <span class="token operator">=</span> module<span class="token punctuation">(</span>x_data<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 计算损失函数</span>    loss <span class="token operator">=</span> criterion<span class="token punctuation">(</span>y_pred<span class="token punctuation">,</span>y_data<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 这个loss实例化后会调用__str__()函数</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>epoch<span class="token punctuation">,</span> loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 所有梯度的权重都归零</span>    optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 反向传播</span>    loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 更新</span>    optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="训练100次后的权重和偏置"><a href="#训练100次后的权重和偏置" class="headerlink" title="训练100次后的权重和偏置"></a>训练100次后的权重和偏置</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>module<span class="token punctuation">.</span>Linear<span class="token punctuation">.</span>weight<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>module<span class="token punctuation">.</span>Linear<span class="token punctuation">.</span>bias<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 我的结果是</span><span class="token comment" spellcheck="true"># w 是 tensor([[3.5878]])</span><span class="token comment" spellcheck="true"># b 是 tensor([0.9371])</span><span class="token comment" spellcheck="true"># y = wx + b</span><span class="token comment" spellcheck="true"># 可以看出训练100次后结果不理想，离我们认知的w是4，b是0还是有较大差距</span><span class="token comment" spellcheck="true"># 优化方案：1.更换损失函数</span><span class="token comment" spellcheck="true"># 2.加大次数</span><span class="token comment" spellcheck="true"># ...</span></code></pre><h2 id="最后测试我们从训练中得到的参数是否能够应用于现实（数据集中未曾出现的）"><a href="#最后测试我们从训练中得到的参数是否能够应用于现实（数据集中未曾出现的）" class="headerlink" title="最后测试我们从训练中得到的参数是否能够应用于现实（数据集中未曾出现的）"></a>最后测试我们从训练中得到的参数是否能够应用于现实（数据集中未曾出现的）</h2><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 测试</span>x_test <span class="token operator">=</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1314.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">123.0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>y_test <span class="token operator">=</span> module<span class="token punctuation">(</span>x_test<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'y_pred='</span><span class="token punctuation">,</span>y_test<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 最后这里我是采用了训练1000次得到的结果进行验证的</span><span class="token comment" spellcheck="true"># 训练1000次后</span><span class="token comment" spellcheck="true"># 我得到w = 3.9996</span><span class="token comment" spellcheck="true"># b = 0.0008</span><span class="token comment" spellcheck="true"># 离我们认知的结果相差不大</span><span class="token comment" spellcheck="true"># 预测</span>y_pred<span class="token operator">=</span> tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">5255.5278</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span> <span class="token number">491.9565</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 可以看出验证结果与事实基本一致</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GUI自动化</title>
      <link href="/486381511/2022/05/11/gui-zi-dong-hua/"/>
      <url>/486381511/2022/05/11/gui-zi-dong-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="简单的自动化处理任务"><a href="#简单的自动化处理任务" class="headerlink" title="简单的自动化处理任务"></a>简单的自动化处理任务</h1><p><strong>pyautogui 是一个封装好的第三方库，它可以完成很多繁琐的任务，包括对鼠标、键盘的控制</strong></p><h2 id="导入必要的库"><a href="#导入必要的库" class="headerlink" title="导入必要的库"></a>导入必要的库</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pyautogui<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 暂停和自动防故障装置# 每次调用pyautogui的函数都有1.5秒的停顿payautogui.PAUSE = 1.5# 设置为True，鼠标放到屏幕左上角，就可以跳出控制pyautogui.FAILSAFE = False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>pyautogui鼠标函数使用x，y坐标，原点(屏幕左上角)x,y为(0,0),都是正，没有负数(类似第四象限)</strong></p><p><strong>获取屏幕坐标大小</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># size()返回一个元组，包含屏幕的宽高的像素值pyautogui.size()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>鼠标的移动</strong><br>绝对位置的移动</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># moveTo()有两个参数# 1.指定位置  2.移动过程需要的的时间pyautogui.moveTo((1000,1000),duration=0.6)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>相对位置的移动，以鼠标当前位置为原点</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># moveRel()接受2个参数# 1.相对位置移动参数  2.移动过程的时间pyautogui.moveRel((500,-300),duration=0.9)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>获取鼠标当前位置坐标</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pyautogui.position()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="鼠标的点击"><a href="#鼠标的点击" class="headerlink" title="鼠标的点击"></a>鼠标的点击</h3><p>点击</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># click()传入两个参数# 1.xy位置# 2.指定鼠标按键 button，值分别为'left','middle','right'代表鼠标三个键pyautogui.click(1000,1000)#不写button，默认就是左键<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按下与释放鼠标</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 按住 pyautogui.mouseDown(1000,1000)time.sleep(2)# 放开pyautogui.mouseUp(1000,1000)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>点击实际上就是封装了这两个方法</strong></p><p>拖动</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 拖动鼠标，拖动意味着移动鼠标，同时按住按钮不放，用法与前面一样pyautogui.dragTo((100,500),duration=2)pyautogui.dragRel((200,900),duration=2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>滚动鼠标</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 滚动鼠标# scroll(),传入一个整型参数，说明向上或向下滚动多少单位,正数向上，负数向下pyautogui.scroll(200)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>特殊操作<br>屏幕截图</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 获取屏幕快照im = pyautogui.screenshot()# im变量将包含一个屏幕快照的Image对象，可以调用Pillow、cv2方法对该Image对象进行操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分析屏幕截图"><a href="#分析屏幕截图" class="headerlink" title="分析屏幕截图"></a>分析屏幕截图</h3><p><strong>分析像素</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 如果屏幕上指定的x和y坐标处的像素与指定的颜色匹配# pyautogui的pixelMatchesColor()函数将返回True# 第一个参数是x和y的坐标,这次不能是元组了,只能分别写具体数# 第二个参数是指定的RGB颜色print(pyautogui.pixelMatchesColor(1000,1000,(255,255,255)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>分析屏幕图像</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 简单图像识别b = pyautogui.locateOnScreen('.\\学习资源\\猫猫.png')# 传入一个图片相对位置# 计算机判断屏幕当前有没有该图片的位置，有就返回一个四个整数元组# (x,y,宽,高)，xy是该图像在屏幕上的左上角位置# 如果有多处就返回一个列表# 把该元组传给center函数，返回中心坐标位置a = pyautogui.center(b)pyautogui.click(a)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 控制键盘# 输入字符串# typewrite有两个参数，一个是字符串，一个是输入每个字符的相隔时间，不写就秒输入pyautogui.typewrite('Hello World',0.25)# 键名的列表print(pyautogui.KEYBOARD_KEYS)# 按下和释放键盘# pyautogui.keyDown()按 和pyautogui.Keyup释放# 合并 pyautogui.press()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这是一个很有意思的库，上限很高，可以搭配各种花里胡哨的库完成一些特殊的操作，例如qq抢红包等等，甚至可搞游戏外挂</strong></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 自动化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cv颜色识别</title>
      <link href="/486381511/2022/05/11/cv-yan-se-shi-bie/"/>
      <url>/486381511/2022/05/11/cv-yan-se-shi-bie/</url>
      
        <content type="html"><![CDATA[<h1 id="颜色识别"><a href="#颜色识别" class="headerlink" title="颜色识别"></a>颜色识别</h1><p><code>找出最大面积的颜色种类，后面按照这个类别进行识别</code></p><h2 id="导入必要库"><a href="#导入必要库" class="headerlink" title="导入必要库"></a>导入必要库</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">import cv2import numpy as npimport datetime<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="加载参数"><a href="#加载参数" class="headerlink" title="加载参数"></a>加载参数</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 加载摄像头cap = cv2.VideoCapture(0, cv2.CAP_DSHOW)# 用于计算后面红色的总面积max_list = []# 用于计算后面蓝色的总面积max1_list = []# 用于计算后面绿色的总面积max2_list = []# 全局变量的keycolor_key = ""# 获取当前时间now_time = datetime.datetime.now()# 5秒的时间对象date_up = datetime.timedelta(seconds=5)# 5秒后的时间my_time = now_time+date_up<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="定义一个找颜色的函数"><a href="#定义一个找颜色的函数" class="headerlink" title="定义一个找颜色的函数"></a>定义一个找颜色的函数</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">def MySnow(image, LowColor, UpColor):    # 思路    # 利用二值化找出颜色区域，使用找轮廓函数找出位置，画上    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)    # ？？？不知道什么操作得到一个卷积核    line = cv2.getStructuringElement(cv2.MORPH_RECT,(15,15),(-1,-1))    # 阈值处理    mask = cv2.inRange(hsv, LowColor, UpColor)    # 形态学运算，开运算,先腐蚀后膨胀的过程    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, line)    # 找出轮廓    contours,hierarchy = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)    # 索引    index = -1    max = 0    # 遍历所有轮廓    for c in range(len(contours)):        # 主要用于计算图像轮廓的面积，找出最大的面积        area = cv2.contourArea(contours[c])        # 有面积        if area &gt; max:            # 面积大于max就等于面积            max = area            # 第几个轮廓            index = c    if index &gt;= 0:        # minAreaRect()函数计算并返回指定点集的最小区域边界斜矩形。        rect = cv2.minAreaRect(contours[index])        # cv2.ellipse()方法用于在任何图像上绘制椭圆        cv2.ellipse(image, rect, (0, 0, 255), 2, 8)        # 画小圆        cv2.circle(image, (np.int32(rect[0][0]), np.int32(rect[0][1])), 2, (0, 255, 0), 2, 8, 0)    # 返回每一帧颜色的最大面积    return image, max<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="定义一个比较总颜色面积大小的函数"><a href="#定义一个比较总颜色面积大小的函数" class="headerlink" title="定义一个比较总颜色面积大小的函数"></a>定义一个比较总颜色面积大小的函数</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">def shuBJ(shu, shu1, shu2):    if shu &gt; shu1:        bigger = shu        key = "red"    else:        bigger = shu1        key = "blue"    if bigger &gt; shu2:        return key    else:        key = "green"        return key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码第一个主体，按时间算出最大面积的颜色类别"><a href="#代码第一个主体，按时间算出最大面积的颜色类别" class="headerlink" title="代码第一个主体，按时间算出最大面积的颜色类别"></a>代码第一个主体，按时间算出最大面积的颜色类别</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 运行设定好的时间，用于采摘颜色面积的数据while datetime.datetime.now() &lt; my_time:    ret, frame = cap.read()    if ret:        # 调用MySnow函数，得到返回值        # 里面是红色的阈值        result, max = MySnow(frame, (0, 43, 46), (10, 255, 255))        # 里面是蓝色的阈值        result1, max1 = MySnow(frame, (100, 43, 46), (124, 255, 255))        # 里面是绿色的阈值        result2, max2 = MySnow(frame, (35, 43, 46), (77, 255, 255))        print(max, max1, max2)        # 把得到的面积各自添加在自己的列表中        max_list.append(max)        max1_list.append(max1)        max2_list.append(max2)        cv2.imshow('result', result2)        c = cv2.waitKey(50)        if c == 32:            break    else:        breakcv2.destroyAllWindows()# 把各自的列表中的元素求和加起来，得到总面积max1_shu = sum(max_list)max2_shu = sum(max1_list)max3_shu = sum(max2_list)print(max1_shu, max2_shu, max3_shu)# 调用shuBJ函数得到关键字，用于记录面积最大的颜色color_key = shuBJ(max1_shu,max2_shu,max3_shu)print(color_key)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码的第二个主体，用于按照得到的key运行代码"><a href="#代码的第二个主体，用于按照得到的key运行代码" class="headerlink" title="代码的第二个主体，用于按照得到的key运行代码"></a>代码的第二个主体，用于按照得到的key运行代码</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 根据前面得到的key运行相对应的代码if color_key == "red":    print("red!!!")    while True:        ret, frame = cap.read()        if ret:            result, max = MySnow(frame, (0, 43, 46), (10, 255, 255))            cv2.imshow('result', result)            c = cv2.waitKey(50)            if c == 32:                break        else:            breakelif color_key == "blue":    print("blue!!!")    while True:        ret, frame = cap.read()        if ret:            result, max = MySnow(frame, (100, 43, 46), (124, 255, 255))            cv2.imshow('result', result)            c = cv2.waitKey(50)            if c == 32:                break        else:            breakelif color_key == "green":    print("green!!!")    while True:        ret, frame = cap.read()        if ret:            result, max = MySnow(frame, (35, 43, 46), (77, 255, 255))            cv2.imshow('result', result)            c = cv2.waitKey(50)            if c == 32:                break        else:            break<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">cv2.waitKey(0)cv2.destroyAllWindows()cap.release()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码还有很大的优化空间，可以自行折腾</strong><br><strong>傻师妹，学会了吗</strong></p>]]></content>
      
      
      <categories>
          
          <category> opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础</title>
      <link href="/486381511/2022/05/10/python/"/>
      <url>/486381511/2022/05/10/python/</url>
      
        <content type="html"><![CDATA[<h1 id="Python笔记"><a href="#Python笔记" class="headerlink" title="Python笔记"></a><strong>Python笔记</strong></h1><h2 id="默认都会"><a href="#默认都会" class="headerlink" title="默认都会"></a>默认都会</h2><p><strong>print(“输出”)<br>input(“提示语句”)<br>if(True) : exp1 else: exp2<br>for i in range(): esp1<br>while (True) : exp1</strong></p><hr><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p><strong>import time<br>import datetime<br>获取当前时间<br>now_time = datetime.datetime.now()<br>设置一个10秒的对象，具体datetime类看文档<br>date_up = datetime.timedelta(seconds=10)<br>现在的时间加上10，就是10秒后的时间了<br>my_time = now_time+date_up<br>使用循环来控制代码十秒后运行<br>while datetime.datetime.now() &lt; my_time:<br>time.sleep(1)<br>print(“Hello World!”)</strong></p><hr><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p><strong>文件的打开有两种格式</strong></p><ul><li><p><strong>使用创建对象打开<br>file = open(‘文件路径’,’操作符’)<br>读取该文件内容<br>file.read()<br>写入<br>file.write()<br>关闭<br>file.close()</strong></p></li><li><p><strong>第二种，推荐使用第二种<br>with open(fp,’操作符’) as fp:<br>fp.write()</strong></p><hr></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
