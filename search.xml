<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>GUI自动化</title>
      <link href="/486381511/2022/05/11/gui-zi-dong-hua/"/>
      <url>/486381511/2022/05/11/gui-zi-dong-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="简单的自动化处理任务"><a href="#简单的自动化处理任务" class="headerlink" title="简单的自动化处理任务"></a>简单的自动化处理任务</h1><p><strong>pyautogui 是一个封装好的第三方库，它可以完成很多繁琐的任务，包括对鼠标、键盘的控制</strong></p><h2 id="导入必要的库"><a href="#导入必要的库" class="headerlink" title="导入必要的库"></a>导入必要的库</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pyautogui<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 暂停和自动防故障装置# 每次调用pyautogui的函数都有1.5秒的停顿payautogui.PAUSE = 1.5# 设置为True，鼠标放到屏幕左上角，就可以跳出控制pyautogui.FAILSAFE = False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>pyautogui鼠标函数使用x，y坐标，原点(屏幕左上角)x,y为(0,0),都是正，没有负数(类似第四象限)</strong></p><p><strong>获取屏幕坐标大小</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># size()返回一个元组，包含屏幕的宽高的像素值pyautogui.size()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>鼠标的移动</strong><br>绝对位置的移动</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># moveTo()有两个参数# 1.指定位置  2.移动过程需要的的时间pyautogui.moveTo((1000,1000),duration=0.6)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>相对位置的移动，以鼠标当前位置为原点</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># moveRel()接受2个参数# 1.相对位置移动参数  2.移动过程的时间pyautogui.moveRel((500,-300),duration=0.9)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>获取鼠标当前位置坐标</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pyautogui.position()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="鼠标的点击"><a href="#鼠标的点击" class="headerlink" title="鼠标的点击"></a>鼠标的点击</h3><p>点击</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># click()传入两个参数# 1.xy位置# 2.指定鼠标按键 button，值分别为'left','middle','right'代表鼠标三个键pyautogui.click(1000,1000)#不写button，默认就是左键<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按下与释放鼠标</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 按住 pyautogui.mouseDown(1000,1000)time.sleep(2)# 放开pyautogui.mouseUp(1000,1000)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>点击实际上就是封装了这两个方法</strong></p><p>拖动</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 拖动鼠标，拖动意味着移动鼠标，同时按住按钮不放，用法与前面一样pyautogui.dragTo((100,500),duration=2)pyautogui.dragRel((200,900),duration=2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>滚动鼠标</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 滚动鼠标# scroll(),传入一个整型参数，说明向上或向下滚动多少单位,正数向上，负数向下pyautogui.scroll(200)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>特殊操作<br>屏幕截图</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 获取屏幕快照im = pyautogui.screenshot()# im变量将包含一个屏幕快照的Image对象，可以调用Pillow、cv2方法对该Image对象进行操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分析屏幕截图"><a href="#分析屏幕截图" class="headerlink" title="分析屏幕截图"></a>分析屏幕截图</h3><p><strong>分析像素</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 如果屏幕上指定的x和y坐标处的像素与指定的颜色匹配# pyautogui的pixelMatchesColor()函数将返回True# 第一个参数是x和y的坐标,这次不能是元组了,只能分别写具体数# 第二个参数是指定的RGB颜色print(pyautogui.pixelMatchesColor(1000,1000,(255,255,255)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>分析屏幕图像</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 简单图像识别b = pyautogui.locateOnScreen('.\\学习资源\\猫猫.png')# 传入一个图片相对位置# 计算机判断屏幕当前有没有该图片的位置，有就返回一个四个整数元组# (x,y,宽,高)，xy是该图像在屏幕上的左上角位置# 如果有多处就返回一个列表# 把该元组传给center函数，返回中心坐标位置a = pyautogui.center(b)pyautogui.click(a)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 控制键盘# 输入字符串# typewrite有两个参数，一个是字符串，一个是输入每个字符的相隔时间，不写就秒输入pyautogui.typewrite('Hello World',0.25)# 键名的列表print(pyautogui.KEYBOARD_KEYS)# 按下和释放键盘# pyautogui.keyDown()按 和pyautogui.Keyup释放# 合并 pyautogui.press()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这是一个很有意思的库，上限很高，可以搭配各种花里胡哨的库完成一些特殊的操作，例如qq抢红包等等，甚至可搞游戏外挂</strong></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 自动化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cv颜色识别</title>
      <link href="/486381511/2022/05/11/cv-yan-se-shi-bie/"/>
      <url>/486381511/2022/05/11/cv-yan-se-shi-bie/</url>
      
        <content type="html"><![CDATA[<h1 id="颜色识别"><a href="#颜色识别" class="headerlink" title="颜色识别"></a>颜色识别</h1><p><code>找出最大面积的颜色种类，后面按照这个类别进行识别</code></p><h2 id="导入必要库"><a href="#导入必要库" class="headerlink" title="导入必要库"></a>导入必要库</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">import cv2import numpy as npimport datetime<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="加载参数"><a href="#加载参数" class="headerlink" title="加载参数"></a>加载参数</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 加载摄像头cap = cv2.VideoCapture(0, cv2.CAP_DSHOW)# 用于计算后面红色的总面积max_list = []# 用于计算后面蓝色的总面积max1_list = []# 用于计算后面绿色的总面积max2_list = []# 全局变量的keycolor_key = ""# 获取当前时间now_time = datetime.datetime.now()# 5秒的时间对象date_up = datetime.timedelta(seconds=5)# 5秒后的时间my_time = now_time+date_up<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="定义一个找颜色的函数"><a href="#定义一个找颜色的函数" class="headerlink" title="定义一个找颜色的函数"></a>定义一个找颜色的函数</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">def MySnow(image, LowColor, UpColor):    # 思路    # 利用二值化找出颜色区域，使用找轮廓函数找出位置，画上    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)    # ？？？不知道什么操作得到一个卷积核    line = cv2.getStructuringElement(cv2.MORPH_RECT,(15,15),(-1,-1))    # 阈值处理    mask = cv2.inRange(hsv, LowColor, UpColor)    # 形态学运算，开运算,先腐蚀后膨胀的过程    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, line)    # 找出轮廓    contours,hierarchy = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)    # 索引    index = -1    max = 0    # 遍历所有轮廓    for c in range(len(contours)):        # 主要用于计算图像轮廓的面积，找出最大的面积        area = cv2.contourArea(contours[c])        # 有面积        if area &gt; max:            # 面积大于max就等于面积            max = area            # 第几个轮廓            index = c    if index &gt;= 0:        # minAreaRect()函数计算并返回指定点集的最小区域边界斜矩形。        rect = cv2.minAreaRect(contours[index])        # cv2.ellipse()方法用于在任何图像上绘制椭圆        cv2.ellipse(image, rect, (0, 0, 255), 2, 8)        # 画小圆        cv2.circle(image, (np.int32(rect[0][0]), np.int32(rect[0][1])), 2, (0, 255, 0), 2, 8, 0)    # 返回每一帧颜色的最大面积    return image, max<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="定义一个比较总颜色面积大小的函数"><a href="#定义一个比较总颜色面积大小的函数" class="headerlink" title="定义一个比较总颜色面积大小的函数"></a>定义一个比较总颜色面积大小的函数</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">def shuBJ(shu, shu1, shu2):    if shu &gt; shu1:        bigger = shu        key = "red"    else:        bigger = shu1        key = "blue"    if bigger &gt; shu2:        return key    else:        key = "green"        return key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码第一个主体，按时间算出最大面积的颜色类别"><a href="#代码第一个主体，按时间算出最大面积的颜色类别" class="headerlink" title="代码第一个主体，按时间算出最大面积的颜色类别"></a>代码第一个主体，按时间算出最大面积的颜色类别</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 运行设定好的时间，用于采摘颜色面积的数据while datetime.datetime.now() &lt; my_time:    ret, frame = cap.read()    if ret:        # 调用MySnow函数，得到返回值        # 里面是红色的阈值        result, max = MySnow(frame, (0, 43, 46), (10, 255, 255))        # 里面是蓝色的阈值        result1, max1 = MySnow(frame, (100, 43, 46), (124, 255, 255))        # 里面是绿色的阈值        result2, max2 = MySnow(frame, (35, 43, 46), (77, 255, 255))        print(max, max1, max2)        # 把得到的面积各自添加在自己的列表中        max_list.append(max)        max1_list.append(max1)        max2_list.append(max2)        cv2.imshow('result', result2)        c = cv2.waitKey(50)        if c == 32:            break    else:        breakcv2.destroyAllWindows()# 把各自的列表中的元素求和加起来，得到总面积max1_shu = sum(max_list)max2_shu = sum(max1_list)max3_shu = sum(max2_list)print(max1_shu, max2_shu, max3_shu)# 调用shuBJ函数得到关键字，用于记录面积最大的颜色color_key = shuBJ(max1_shu,max2_shu,max3_shu)print(color_key)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码的第二个主体，用于按照得到的key运行代码"><a href="#代码的第二个主体，用于按照得到的key运行代码" class="headerlink" title="代码的第二个主体，用于按照得到的key运行代码"></a>代码的第二个主体，用于按照得到的key运行代码</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 根据前面得到的key运行相对应的代码if color_key == "red":    print("red!!!")    while True:        ret, frame = cap.read()        if ret:            result, max = MySnow(frame, (0, 43, 46), (10, 255, 255))            cv2.imshow('result', result)            c = cv2.waitKey(50)            if c == 32:                break        else:            breakelif color_key == "blue":    print("blue!!!")    while True:        ret, frame = cap.read()        if ret:            result, max = MySnow(frame, (100, 43, 46), (124, 255, 255))            cv2.imshow('result', result)            c = cv2.waitKey(50)            if c == 32:                break        else:            breakelif color_key == "green":    print("green!!!")    while True:        ret, frame = cap.read()        if ret:            result, max = MySnow(frame, (35, 43, 46), (77, 255, 255))            cv2.imshow('result', result)            c = cv2.waitKey(50)            if c == 32:                break        else:            break<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">cv2.waitKey(0)cv2.destroyAllWindows()cap.release()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码还有很大的优化空间，可以自行折腾</strong><br><strong>傻师妹，学会了吗</strong></p>]]></content>
      
      
      <categories>
          
          <category> opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础</title>
      <link href="/486381511/2022/05/10/python/"/>
      <url>/486381511/2022/05/10/python/</url>
      
        <content type="html"><![CDATA[<h1 id="Python笔记"><a href="#Python笔记" class="headerlink" title="Python笔记"></a><strong>Python笔记</strong></h1><h2 id="默认都会"><a href="#默认都会" class="headerlink" title="默认都会"></a>默认都会</h2><p><strong>print(“输出”)<br>input(“提示语句”)<br>if(True) : exp1 else: exp2<br>for i in range(): esp1<br>while (True) : exp1</strong></p><hr><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p><strong>import time<br>import datetime<br>获取当前时间<br>now_time = datetime.datetime.now()<br>设置一个10秒的对象，具体datetime类看文档<br>date_up = datetime.timedelta(seconds=10)<br>现在的时间加上10，就是10秒后的时间了<br>my_time = now_time+date_up<br>使用循环来控制代码十秒后运行<br>while datetime.datetime.now() &lt; my_time:<br>time.sleep(1)<br>print(“Hello World!”)</strong></p><hr><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p><strong>文件的打开有两种格式</strong></p><ul><li><p><strong>使用创建对象打开<br>file = open(‘文件路径’,’操作符’)<br>读取该文件内容<br>file.read()<br>写入<br>file.write()<br>关闭<br>file.close()</strong></p></li><li><p><strong>第二种，推荐使用第二种<br>with open(fp,’操作符’) as fp:<br>fp.write()</strong></p><hr></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
