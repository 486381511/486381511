<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>构建简单网络</title>
      <link href="/486381511/2022/05/15/gou-jian-jian-dan-wang-luo/"/>
      <url>/486381511/2022/05/15/gou-jian-jian-dan-wang-luo/</url>
      
        <content type="html"><![CDATA[<h1 id="深度学习————简单示例"><a href="#深度学习————简单示例" class="headerlink" title="深度学习————简单示例"></a>深度学习————简单示例</h1><h3 id="由数据和结果，推断中间过程，得到一个结果网络可以用于预测和识别物体"><a href="#由数据和结果，推断中间过程，得到一个结果网络可以用于预测和识别物体" class="headerlink" title="由数据和结果，推断中间过程，得到一个结果网络可以用于预测和识别物体"></a>由数据和结果，推断中间过程，得到一个结果网络可以用于预测和识别物体</h3><h3 id="任务：由数据-1-0-2-0-3-0"><a href="#任务：由数据-1-0-2-0-3-0" class="headerlink" title="任务：由数据 1.0 2.0 3.0"></a>任务：由数据 1.0 2.0 3.0</h3><h3 id="结果：4-0-8-0-12-0"><a href="#结果：4-0-8-0-12-0" class="headerlink" title="结果：4.0 8.0 12.0"></a>结果：4.0 8.0 12.0</h3><h3 id="推断中间过程（人眼很简单可以看出关系是乘上4得到结果）"><a href="#推断中间过程（人眼很简单可以看出关系是乘上4得到结果）" class="headerlink" title="推断中间过程（人眼很简单可以看出关系是乘上4得到结果）"></a>推断中间过程（人眼很简单可以看出关系是乘上4得到结果）</h3><h2 id="导入torch"><a href="#导入torch" class="headerlink" title="导入torch"></a>导入torch</h2><p><strong>pytorch是一个基本的深度学习框架，封装好了各种方法</strong></p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> torch</code></pre><h2 id="准备数据和结果"><a href="#准备数据和结果" class="headerlink" title="准备数据和结果"></a>准备数据和结果</h2><pre class=" language-python"><code class="language-python">x_data <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3.0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>y_data <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">4.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">8.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">12.0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h2 id="构建你的模型"><a href="#构建你的模型" class="headerlink" title="构建你的模型"></a>构建你的模型</h2><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 设计模型</span><span class="token keyword">class</span> <span class="token class-name">LinearModel</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 没有backward，torch.nn.Module 中会自动算来的</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 调用父类构造</span>        super<span class="token punctuation">(</span>LinearModel<span class="token punctuation">,</span>self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 实例化Linear对象，包含了权重w和偏置b，第一个1是输入维数，第二个1是输出维数</span>        self<span class="token punctuation">.</span>linear <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Linear<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 向前传播</span>    <span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 传入x，自动算 y = wx+b</span>        y_pred <span class="token operator">=</span> self<span class="token punctuation">.</span>linear<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">return</span> y_pred<span class="token comment" spellcheck="true"># 创建模型对象</span>module <span class="token operator">=</span> LinearModel<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="构建损失函数和优化器"><a href="#构建损失函数和优化器" class="headerlink" title="构建损失函数和优化器"></a>构建损失函数和优化器</h2><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 构造损失函数和优化器</span><span class="token comment" spellcheck="true"># 实例化，损失函数，将来给y'和y就可以算出loss，MSE平方损失函数</span>criterion <span class="token operator">=</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>MSELoss<span class="token punctuation">(</span>size_average<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 不乘上1/N</span><span class="token comment" spellcheck="true"># 优化器，优化optim模块里面的一个SGD类，实例化，module.parameters()会检查所有成员，如果这个成员有相应的权重就把这些都加都训练集合上</span><span class="token comment" spellcheck="true"># lr：学习率</span>optimizer <span class="token operator">=</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>SGD<span class="token punctuation">(</span>module<span class="token punctuation">.</span>parameters<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>lr<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># w=w-lr*(dloss/dw)</span></code></pre><h2 id="训练（向前传播、反向传播和更新权重偏置）"><a href="#训练（向前传播、反向传播和更新权重偏置）" class="headerlink" title="训练（向前传播、反向传播和更新权重偏置）"></a>训练（向前传播、反向传播和更新权重偏置）</h2><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 先训练一百次</span><span class="token keyword">for</span> epoch <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 送入x_data数据集，然后算 y'=wx+b</span>    y_pred <span class="token operator">=</span> module<span class="token punctuation">(</span>x_data<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 计算损失函数</span>    loss <span class="token operator">=</span> criterion<span class="token punctuation">(</span>y_pred<span class="token punctuation">,</span>y_data<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 这个loss实例化后会调用__str__()函数</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>epoch<span class="token punctuation">,</span> loss<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 所有梯度的权重都归零</span>    optimizer<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 反向传播</span>    loss<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 更新</span>    optimizer<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h2 id="训练100次后的权重和偏置"><a href="#训练100次后的权重和偏置" class="headerlink" title="训练100次后的权重和偏置"></a>训练100次后的权重和偏置</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>module<span class="token punctuation">.</span>Linear<span class="token punctuation">.</span>weight<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>module<span class="token punctuation">.</span>Linear<span class="token punctuation">.</span>bias<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 我的结果是</span><span class="token comment" spellcheck="true"># w 是 tensor([[3.5878]])</span><span class="token comment" spellcheck="true"># b 是 tensor([0.9371])</span><span class="token comment" spellcheck="true"># y = wx + b</span><span class="token comment" spellcheck="true"># 可以看出训练100次后结果不理想，离我们认知的w是4，b是0还是有较大差距</span><span class="token comment" spellcheck="true"># 优化方案：1.更换损失函数</span><span class="token comment" spellcheck="true"># 2.加大次数</span><span class="token comment" spellcheck="true"># ...</span></code></pre><h2 id="最后测试我们从训练中得到的参数是否能够应用于现实（数据集中未曾出现的）"><a href="#最后测试我们从训练中得到的参数是否能够应用于现实（数据集中未曾出现的）" class="headerlink" title="最后测试我们从训练中得到的参数是否能够应用于现实（数据集中未曾出现的）"></a>最后测试我们从训练中得到的参数是否能够应用于现实（数据集中未曾出现的）</h2><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 测试</span>x_test <span class="token operator">=</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1314.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">123.0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>y_test <span class="token operator">=</span> module<span class="token punctuation">(</span>x_test<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'y_pred='</span><span class="token punctuation">,</span>y_test<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 最后这里我是采用了训练1000次得到的结果进行验证的</span><span class="token comment" spellcheck="true"># 训练1000次后</span><span class="token comment" spellcheck="true"># 我得到w = 3.9996</span><span class="token comment" spellcheck="true"># b = 0.0008</span><span class="token comment" spellcheck="true"># 离我们认知的结果相差不大</span><span class="token comment" spellcheck="true"># 预测</span>y_pred<span class="token operator">=</span> tensor<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">5255.5278</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token punctuation">[</span> <span class="token number">491.9565</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 可以看出验证结果与事实基本一致</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GUI自动化</title>
      <link href="/486381511/2022/05/11/gui-zi-dong-hua/"/>
      <url>/486381511/2022/05/11/gui-zi-dong-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="简单的自动化处理任务"><a href="#简单的自动化处理任务" class="headerlink" title="简单的自动化处理任务"></a>简单的自动化处理任务</h1><p><strong>pyautogui 是一个封装好的第三方库，它可以完成很多繁琐的任务，包括对鼠标、键盘的控制</strong></p><h2 id="导入必要的库"><a href="#导入必要的库" class="headerlink" title="导入必要的库"></a>导入必要的库</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">import pyautogui<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 暂停和自动防故障装置# 每次调用pyautogui的函数都有1.5秒的停顿payautogui.PAUSE = 1.5# 设置为True，鼠标放到屏幕左上角，就可以跳出控制pyautogui.FAILSAFE = False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>pyautogui鼠标函数使用x，y坐标，原点(屏幕左上角)x,y为(0,0),都是正，没有负数(类似第四象限)</strong></p><p><strong>获取屏幕坐标大小</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># size()返回一个元组，包含屏幕的宽高的像素值pyautogui.size()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>鼠标的移动</strong><br>绝对位置的移动</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># moveTo()有两个参数# 1.指定位置  2.移动过程需要的的时间pyautogui.moveTo((1000,1000),duration=0.6)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>相对位置的移动，以鼠标当前位置为原点</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># moveRel()接受2个参数# 1.相对位置移动参数  2.移动过程的时间pyautogui.moveRel((500,-300),duration=0.9)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>获取鼠标当前位置坐标</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">pyautogui.position()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="鼠标的点击"><a href="#鼠标的点击" class="headerlink" title="鼠标的点击"></a>鼠标的点击</h3><p>点击</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># click()传入两个参数# 1.xy位置# 2.指定鼠标按键 button，值分别为'left','middle','right'代表鼠标三个键pyautogui.click(1000,1000)#不写button，默认就是左键<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>按下与释放鼠标</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 按住 pyautogui.mouseDown(1000,1000)time.sleep(2)# 放开pyautogui.mouseUp(1000,1000)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>点击实际上就是封装了这两个方法</strong></p><p>拖动</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 拖动鼠标，拖动意味着移动鼠标，同时按住按钮不放，用法与前面一样pyautogui.dragTo((100,500),duration=2)pyautogui.dragRel((200,900),duration=2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>滚动鼠标</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 滚动鼠标# scroll(),传入一个整型参数，说明向上或向下滚动多少单位,正数向上，负数向下pyautogui.scroll(200)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>特殊操作<br>屏幕截图</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 获取屏幕快照im = pyautogui.screenshot()# im变量将包含一个屏幕快照的Image对象，可以调用Pillow、cv2方法对该Image对象进行操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分析屏幕截图"><a href="#分析屏幕截图" class="headerlink" title="分析屏幕截图"></a>分析屏幕截图</h3><p><strong>分析像素</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 如果屏幕上指定的x和y坐标处的像素与指定的颜色匹配# pyautogui的pixelMatchesColor()函数将返回True# 第一个参数是x和y的坐标,这次不能是元组了,只能分别写具体数# 第二个参数是指定的RGB颜色print(pyautogui.pixelMatchesColor(1000,1000,(255,255,255)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>分析屏幕图像</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 简单图像识别b = pyautogui.locateOnScreen('.\\学习资源\\猫猫.png')# 传入一个图片相对位置# 计算机判断屏幕当前有没有该图片的位置，有就返回一个四个整数元组# (x,y,宽,高)，xy是该图像在屏幕上的左上角位置# 如果有多处就返回一个列表# 把该元组传给center函数，返回中心坐标位置a = pyautogui.center(b)pyautogui.click(a)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 控制键盘# 输入字符串# typewrite有两个参数，一个是字符串，一个是输入每个字符的相隔时间，不写就秒输入pyautogui.typewrite('Hello World',0.25)# 键名的列表print(pyautogui.KEYBOARD_KEYS)# 按下和释放键盘# pyautogui.keyDown()按 和pyautogui.Keyup释放# 合并 pyautogui.press()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这是一个很有意思的库，上限很高，可以搭配各种花里胡哨的库完成一些特殊的操作，例如qq抢红包等等，甚至可搞游戏外挂</strong></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 自动化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cv颜色识别</title>
      <link href="/486381511/2022/05/11/cv-yan-se-shi-bie/"/>
      <url>/486381511/2022/05/11/cv-yan-se-shi-bie/</url>
      
        <content type="html"><![CDATA[<h1 id="颜色识别"><a href="#颜色识别" class="headerlink" title="颜色识别"></a>颜色识别</h1><p><code>找出最大面积的颜色种类，后面按照这个类别进行识别</code></p><h2 id="导入必要库"><a href="#导入必要库" class="headerlink" title="导入必要库"></a>导入必要库</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">import cv2import numpy as npimport datetime<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="加载参数"><a href="#加载参数" class="headerlink" title="加载参数"></a>加载参数</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 加载摄像头cap = cv2.VideoCapture(0, cv2.CAP_DSHOW)# 用于计算后面红色的总面积max_list = []# 用于计算后面蓝色的总面积max1_list = []# 用于计算后面绿色的总面积max2_list = []# 全局变量的keycolor_key = ""# 获取当前时间now_time = datetime.datetime.now()# 5秒的时间对象date_up = datetime.timedelta(seconds=5)# 5秒后的时间my_time = now_time+date_up<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="定义一个找颜色的函数"><a href="#定义一个找颜色的函数" class="headerlink" title="定义一个找颜色的函数"></a>定义一个找颜色的函数</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">def MySnow(image, LowColor, UpColor):    # 思路    # 利用二值化找出颜色区域，使用找轮廓函数找出位置，画上    hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)    # ？？？不知道什么操作得到一个卷积核    line = cv2.getStructuringElement(cv2.MORPH_RECT,(15,15),(-1,-1))    # 阈值处理    mask = cv2.inRange(hsv, LowColor, UpColor)    # 形态学运算，开运算,先腐蚀后膨胀的过程    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, line)    # 找出轮廓    contours,hierarchy = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)    # 索引    index = -1    max = 0    # 遍历所有轮廓    for c in range(len(contours)):        # 主要用于计算图像轮廓的面积，找出最大的面积        area = cv2.contourArea(contours[c])        # 有面积        if area &gt; max:            # 面积大于max就等于面积            max = area            # 第几个轮廓            index = c    if index &gt;= 0:        # minAreaRect()函数计算并返回指定点集的最小区域边界斜矩形。        rect = cv2.minAreaRect(contours[index])        # cv2.ellipse()方法用于在任何图像上绘制椭圆        cv2.ellipse(image, rect, (0, 0, 255), 2, 8)        # 画小圆        cv2.circle(image, (np.int32(rect[0][0]), np.int32(rect[0][1])), 2, (0, 255, 0), 2, 8, 0)    # 返回每一帧颜色的最大面积    return image, max<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="定义一个比较总颜色面积大小的函数"><a href="#定义一个比较总颜色面积大小的函数" class="headerlink" title="定义一个比较总颜色面积大小的函数"></a>定义一个比较总颜色面积大小的函数</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">def shuBJ(shu, shu1, shu2):    if shu &gt; shu1:        bigger = shu        key = "red"    else:        bigger = shu1        key = "blue"    if bigger &gt; shu2:        return key    else:        key = "green"        return key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码第一个主体，按时间算出最大面积的颜色类别"><a href="#代码第一个主体，按时间算出最大面积的颜色类别" class="headerlink" title="代码第一个主体，按时间算出最大面积的颜色类别"></a>代码第一个主体，按时间算出最大面积的颜色类别</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 运行设定好的时间，用于采摘颜色面积的数据while datetime.datetime.now() &lt; my_time:    ret, frame = cap.read()    if ret:        # 调用MySnow函数，得到返回值        # 里面是红色的阈值        result, max = MySnow(frame, (0, 43, 46), (10, 255, 255))        # 里面是蓝色的阈值        result1, max1 = MySnow(frame, (100, 43, 46), (124, 255, 255))        # 里面是绿色的阈值        result2, max2 = MySnow(frame, (35, 43, 46), (77, 255, 255))        print(max, max1, max2)        # 把得到的面积各自添加在自己的列表中        max_list.append(max)        max1_list.append(max1)        max2_list.append(max2)        cv2.imshow('result', result2)        c = cv2.waitKey(50)        if c == 32:            break    else:        breakcv2.destroyAllWindows()# 把各自的列表中的元素求和加起来，得到总面积max1_shu = sum(max_list)max2_shu = sum(max1_list)max3_shu = sum(max2_list)print(max1_shu, max2_shu, max3_shu)# 调用shuBJ函数得到关键字，用于记录面积最大的颜色color_key = shuBJ(max1_shu,max2_shu,max3_shu)print(color_key)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码的第二个主体，用于按照得到的key运行代码"><a href="#代码的第二个主体，用于按照得到的key运行代码" class="headerlink" title="代码的第二个主体，用于按照得到的key运行代码"></a>代码的第二个主体，用于按照得到的key运行代码</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 根据前面得到的key运行相对应的代码if color_key == "red":    print("red!!!")    while True:        ret, frame = cap.read()        if ret:            result, max = MySnow(frame, (0, 43, 46), (10, 255, 255))            cv2.imshow('result', result)            c = cv2.waitKey(50)            if c == 32:                break        else:            breakelif color_key == "blue":    print("blue!!!")    while True:        ret, frame = cap.read()        if ret:            result, max = MySnow(frame, (100, 43, 46), (124, 255, 255))            cv2.imshow('result', result)            c = cv2.waitKey(50)            if c == 32:                break        else:            breakelif color_key == "green":    print("green!!!")    while True:        ret, frame = cap.read()        if ret:            result, max = MySnow(frame, (35, 43, 46), (77, 255, 255))            cv2.imshow('result', result)            c = cv2.waitKey(50)            if c == 32:                break        else:            break<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">cv2.waitKey(0)cv2.destroyAllWindows()cap.release()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>代码还有很大的优化空间，可以自行折腾</strong><br><strong>傻师妹，学会了吗</strong></p>]]></content>
      
      
      <categories>
          
          <category> opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础</title>
      <link href="/486381511/2022/05/10/python/"/>
      <url>/486381511/2022/05/10/python/</url>
      
        <content type="html"><![CDATA[<h1 id="Python笔记"><a href="#Python笔记" class="headerlink" title="Python笔记"></a><strong>Python笔记</strong></h1><h2 id="默认都会"><a href="#默认都会" class="headerlink" title="默认都会"></a>默认都会</h2><p><strong>print(“输出”)<br>input(“提示语句”)<br>if(True) : exp1 else: exp2<br>for i in range(): esp1<br>while (True) : exp1</strong></p><hr><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p><strong>import time<br>import datetime<br>获取当前时间<br>now_time = datetime.datetime.now()<br>设置一个10秒的对象，具体datetime类看文档<br>date_up = datetime.timedelta(seconds=10)<br>现在的时间加上10，就是10秒后的时间了<br>my_time = now_time+date_up<br>使用循环来控制代码十秒后运行<br>while datetime.datetime.now() &lt; my_time:<br>time.sleep(1)<br>print(“Hello World!”)</strong></p><hr><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p><strong>文件的打开有两种格式</strong></p><ul><li><p><strong>使用创建对象打开<br>file = open(‘文件路径’,’操作符’)<br>读取该文件内容<br>file.read()<br>写入<br>file.write()<br>关闭<br>file.close()</strong></p></li><li><p><strong>第二种，推荐使用第二种<br>with open(fp,’操作符’) as fp:<br>fp.write()</strong></p><hr></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
